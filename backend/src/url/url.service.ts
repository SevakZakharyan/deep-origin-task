import {Injectable, NotFoundException} from '@nestjs/common';
import { ShortLinksRepository } from "@app/postgres-client/repositories/short-links.repository";
import { ShortLink } from '../../generated/prisma';
import { randomUUID } from 'crypto';

@Injectable()
export class UrlService {
  
  constructor(private readonly shortLinksRepository: ShortLinksRepository) {}
  
  private readonly CHARACTERS: string = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  private readonly BASE: number = 62;
  private readonly SHORT_URL_BASE: string = process.env.FRONTEND_URL || 'http://localhost:4000';
  private readonly SLUG_LENGTH: number = 5;
  private readonly RESERVED_SLUGS = ['links', 'api'];
  
  public async redirectToOriginalUrl(slug: string): Promise<string> {
    const record = await this.shortLinksRepository.findOneByCondition({
      where: { slug },
    });

    if (!record) {
      throw new NotFoundException(`Short URL not found: ${slug}`);
    }

    await this.shortLinksRepository.update(
      { id: record.id },
      { clickCount: record.clickCount + 1 }
    );
    
    return record.originalUrl;
  }

  public async shortenUrl(originalUrl: string, customSlug?: string): Promise<string> {
    if (customSlug) {
      return await this.createCustomSLug(originalUrl, customSlug);
    }
    
    return await this.createAutogeneratedSlug(originalUrl);
  }
  
  private async createAutogeneratedSlug(originalUrl: string): Promise<string> {
    let slug = this.generateUUIDSlug();
    
    while (this.RESERVED_SLUGS.includes(slug.toLowerCase())) {
      slug = this.generateUUIDSlug();
    }
    
    const record = await this.shortLinksRepository.create({
      slug,
      originalUrl,
      shortUrl: `${this.SHORT_URL_BASE}/${slug}`,
      clickCount: 0,
      isCustomSlug: false,
    });
    
    return record.shortUrl;
  }
  
  public async getLinks(): Promise<ShortLink[]> {
    const condition = {
      orderBy: {
        clickCount: 'desc',
      },
    };

    return await this.shortLinksRepository.findByCondition(condition);
  }
  
  private async createCustomSLug(originalUrl: string, customSlug: string): Promise<string> {
    const isAvailable = await this.checkIfSlugAllowed(customSlug);
    
    if (!isAvailable) {
      throw new Error(`Slug "${customSlug}" is already taken. Please choose a different slug.`);
    }
    
    const record = await this.shortLinksRepository.create({
      slug: customSlug,
      originalUrl,
      shortUrl: `${this.SHORT_URL_BASE}/${customSlug}`,
      clickCount: 0,
      isCustomSlug: true,
    });
    
    return record.shortUrl;
  }
  
  private generateUUIDSlug(): string {
    const uuid = randomUUID();
    const base62Slug = this.convertUUIDToBase62(uuid);

    return base62Slug.substring(0, this.SLUG_LENGTH);
  }
  
  private convertUUIDToBase62(uuid: string): string {
    const hex = uuid.replace(/-/g, '');
    const decimal = BigInt('0x' + hex);
    
    let result = '';
    let num = decimal;
    
    if (num === 0n) {
      result = '0';
    } else {
      while (num > 0) {
        result = this.CHARACTERS[Number(num % BigInt(this.BASE))] + result;
        num = num / BigInt(this.BASE);
      }
    }

    while (result.length < this.SLUG_LENGTH) {
      result = '0' + result;
    }
    
    return result;
  }
  
  private async checkIfSlugAllowed(slug: string): Promise<boolean> {
    if (this.RESERVED_SLUGS.includes(slug.toLowerCase())) {
      return false;
    }
    
    const record = await this.shortLinksRepository.findOneByCondition({
      where: { slug },
    });

    return !record;
  }
}
